import React, { useEffect, useMemo, useRef, useState } from "react";

// ‚úÖ Single-file Minesweeper React Component
// - Linksklick: Feld aufdecken
// - Rechtsklick / langes Tippen: Flagge setzen
// - Erster Klick ist immer sicher (Minen werden erst dann gelegt)
// - Timer, Z√§hler, Neustart, Presets (Einsteiger/Profi)
// - Schlankes UI mit Tailwind-Klassen

// Hilfsfunktionen
const clamp = (n, min, max) => Math.max(min, Math.min(max, n));

function createEmptyBoard(rows, cols) {
  const board = [];
  for (let r = 0; r < rows; r++) {
    const row = [];
    for (let c = 0; c < cols; c++) {
      row.push({
        r,
        c,
        isMine: false,
        adjacent: 0,
        revealed: false,
        flagged: false,
        exploded: false,
      });
    }
    board.push(row);
  }
  return board;
}

function neighbors(rows, cols, r, c) {
  const res = [];
  for (let dr = -1; dr <= 1; dr++) {
    for (let dc = -1; dc <= 1; dc++) {
      if (dr === 0 && dc === 0) continue;
      const nr = r + dr;
      const nc = c + dc;
      if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) res.push([nr, nc]);
    }
  }
  return res;
}

function plantMines(board, rows, cols, mines, safeR, safeC) {
  // Lege Minen, vermeide das erste angeklickte Feld und seine Nachbarn
  const forbidden = new Set([[safeR, safeC], ...neighbors(rows, cols, safeR, safeC)].map(([rr, cc]) => rr + "," + cc));
  const all = [];
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const key = r + "," + c;
      if (!forbidden.has(key)) all.push([r, c]);
    }
  }
  // Mische
  for (let i = all.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [all[i], all[j]] = [all[j], all[i]];
  }
  const chosen = all.slice(0, mines);
  for (const [r, c] of chosen) board[r][c].isMine = true;
  // Adjacent z√§hlen
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (board[r][c].isMine) continue;
      board[r][c].adjacent = neighbors(rows, cols, r, c).reduce((acc, [nr, nc]) => acc + (board[nr][nc].isMine ? 1 : 0), 0);
    }
  }
}

function floodReveal(board, rows, cols, r, c, visited = new Set()) {
  const key = r + "," + c;
  if (visited.has(key)) return;
  visited.add(key);
  const cell = board[r][c];
  if (cell.revealed || cell.flagged) return;
  cell.revealed = true;
  if (cell.adjacent === 0 && !cell.isMine) {
    for (const [nr, nc] of neighbors(rows, cols, r, c)) floodReveal(board, rows, cols, nr, nc, visited);
  }
}

function countUnrevealedSafe(board, rows, cols) {
  let count = 0;
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const cell = board[r][c];
      if (!cell.revealed && !cell.isMine) count++;
    }
  }
  return count;
}

function deepClone(board) {
  return board.map((row) => row.map((cell) => ({ ...cell })));
}

export default function Minesweeper() {
  // Presets
  const PRESETS = {
    Beginner: { rows: 9, cols: 9, mines: 10 },
    Fortgeschritten: { rows: 16, cols: 16, mines: 40 },
    Experte: { rows: 16, cols: 30, mines: 99 },
    Custom: null,
  };

  const [preset, setPreset] = useState("Beginner");
  const [rows, setRows] = useState(9);
  const [cols, setCols] = useState(9);
  const [mines, setMines] = useState(10);

  const [board, setBoard] = useState(() => createEmptyBoard(rows, cols));
  const [started, setStarted] = useState(false); // wurden Minen schon gelegt?
  const [state, setState] = useState(/** @type {"ready"|"playing"|"won"|"lost"} */("ready"));
  const [flags, setFlags] = useState(0);
  const [time, setTime] = useState(0);
  const timerRef = useRef(null);

  // Timer
  useEffect(() => {
    if (state === "playing") {
      timerRef.current = setInterval(() => setTime((t) => t + 1), 1000);
    }
    return () => {
      if (timerRef.current) clearInterval(timerRef.current);
    };
  }, [state]);

  // Flags neu z√§hlen, wenn Board wechselt
  useEffect(() => {
    let f = 0;
    for (const row of board) for (const cell of row) if (cell.flagged) f++;
    setFlags(f);
  }, [board]);

  const remainingFlags = Math.max(0, mines - flags);

  function reset(newRows = rows, newCols = cols, newMines = mines) {
    setState("ready");
    setStarted(false);
    setTime(0);
    const r = clamp(newRows, 2, 40);
    const c = clamp(newCols, 2, 60);
    const m = clamp(newMines, 1, r * c - 1);
    setRows(r);
    setCols(c);
    setMines(m);
    setBoard(createEmptyBoard(r, c));
  }

  function applyPreset(name) {
    setPreset(name);
    if (name !== "Custom") {
      const p = PRESETS[name];
      reset(p.rows, p.cols, p.mines);
    }
  }

  function ensurePlanted(safeR, safeC) {
    if (started) return;
    const next = deepClone(board);
    plantMines(next, rows, cols, mines, safeR, safeC);
    setBoard(next);
    setStarted(true);
    setState("playing");
  }

  function reveal(r, c) {
    if (state === "lost" || state === "won") return;
    const cur = deepClone(board);
    if (!started) ensurePlanted(r, c);
    const cell = cur[r][c];
    if (cell.revealed || cell.flagged) return;
    if (cell.isMine) {
      // Spiel verloren
      cell.exploded = true;
      cell.revealed = true;
      // alle Minen zeigen
      for (let rr = 0; rr < rows; rr++)
        for (let cc = 0; cc < cols; cc++) if (cur[rr][cc].isMine) cur[rr][cc].revealed = true;
      setBoard(cur);
      setState("lost");
      return;
    }
    floodReveal(cur, rows, cols, r, c);
    // Gewinn?
    if (countUnrevealedSafe(cur, rows, cols) === 0) {
      // alle Minen automatisch flaggen
      for (let rr = 0; rr < rows; rr++)
        for (let cc = 0; cc < cols; cc++) if (cur[rr][cc].isMine) cur[rr][cc].flagged = true;
      setBoard(cur);
      setState("won");
      return;
    }
    setBoard(cur);
  }

  function toggleFlag(e, r, c) {
    e.preventDefault();
    if (state === "lost" || state === "won") return;
    const cur = deepClone(board);
    const cell = cur[r][c];
    if (cell.revealed) return;
    if (!cell.flagged && flags >= mines) return; // keine negativen Flaggen
    cell.flagged = !cell.flagged;
    setBoard(cur);
  }

  function chordReveal(r, c) {
    // Aufgedecktes Feld mit korrekter Flaggenanzahl: decke Nachbarn auf
    const cell = board[r][c];
    if (!cell.revealed || cell.adjacent === 0) return;
    const nb = neighbors(rows, cols, r, c);
    const flaggedCount = nb.reduce((acc, [nr, nc]) => acc + (board[nr][nc].flagged ? 1 : 0), 0);
    if (flaggedCount !== cell.adjacent) return;
    for (const [nr, nc] of nb) if (!board[nr][nc].flagged) reveal(nr, nc);
  }

  const face = state === "lost" ? "üòµ" : state === "won" ? "üòé" : state === "playing" ? "üôÇ" : "üôÇ";

  // Tastatur-Navigation (optional, Fokus bleibt auf Wrapper)
  const [focusPos, setFocusPos] = useState({ r: 0, c: 0 });
  function onKeyDown(e) {
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " ", "Enter", "f", "F"].includes(e.key)) e.preventDefault();
    if (e.key === "ArrowUp") setFocusPos((p) => ({ r: clamp(p.r - 1, 0, rows - 1), c: p.c }));
    if (e.key === "ArrowDown") setFocusPos((p) => ({ r: clamp(p.r + 1, 0, rows - 1), c: p.c }));
    if (e.key === "ArrowLeft") setFocusPos((p) => ({ r: p.r, c: clamp(p.c - 1, 0, cols - 1) }));
    if (e.key === "ArrowRight") setFocusPos((p) => ({ r: p.r, c: clamp(p.c + 1, 0, cols - 1) }));
    if (e.key === " " || e.key === "Enter") reveal(focusPos.r, focusPos.c);
    if (e.key === "f" || e.key === "F") toggleFlag({ preventDefault() {} }, focusPos.r, focusPos.c);
  }

  // Anzeigeformat Timer/Z√§hler
  const timeStr = useMemo(() => new Date(time * 1000).toISOString().substr(14, 5), [time]);

  return (
    <div className="min-h-screen w-full bg-gradient-to-b from-slate-900 via-slate-800 to-slate-900 text-slate-100 flex items-start justify-center p-6" onKeyDown={onKeyDown} tabIndex={0}>
      <div className="w-full max-w-5xl">
        <header className="mb-4 flex flex-col sm:flex-row items-center justify-between gap-3">
          <h1 className="text-2xl sm:text-3xl font-bold tracking-tight">Minesweeper <span className="opacity-70 text-sm align-middle">React</span></h1>
          <div className="flex flex-wrap items-center gap-2">
            {Object.keys(PRESETS).map((name) => (
              <button
                key={name}
                onClick={() => applyPreset(name)}
                className={`px-3 py-1.5 rounded-xl text-sm border ${preset === name ? "bg-sky-500/20 border-sky-400" : "border-slate-600 hover:border-slate-400"}`}
              >
                {name}
              </button>
            ))}
            {preset === "Custom" && (
              <div className="flex items-center gap-2">
                <label className="text-xs opacity-80">Zeilen</label>
                <input className="w-16 rounded-lg bg-slate-800 border border-slate-600 px-2 py-1" type="number" min={2} max={40} value={rows} onChange={(e) => setRows(clamp(parseInt(e.target.value || 0), 2, 40))} />
                <label className="text-xs opacity-80">Spalten</label>
                <input className="w-16 rounded-lg bg-slate-800 border border-slate-600 px-2 py-1" type="number" min={2} max={60} value={cols} onChange={(e) => setCols(clamp(parseInt(e.target.value || 0), 2, 60))} />
                <label className="text-xs opacity-80">Minen</label>
                <input className="w-20 rounded-lg bg-slate-800 border border-slate-600 px-2 py-1" type="number" min={1} max={rows * cols - 1} value={mines} onChange={(e) => setMines(clamp(parseInt(e.target.value || 0), 1, rows * cols - 1))} />
                <button onClick={() => reset(rows, cols, mines)} className="px-3 py-1.5 rounded-xl text-sm border border-slate-600 hover:border-slate-400">√úbernehmen</button>
              </div>
            )}
          </div>
        </header>

        <div className="rounded-2xl bg-slate-900/60 border border-slate-700 shadow-xl p-4">
          <div className="flex items-center justify-between gap-2 mb-4">
            <div className="flex items-center gap-3">
              <div className="text-xs uppercase tracking-wider opacity-70">Minen</div>
              <div className="text-lg font-mono tabular-nums">{mines}</div>
            </div>
            <button
              onClick={() => reset()}
              className="text-2xl select-none px-3 py-1 rounded-xl border border-slate-600 hover:border-slate-400"
              title="Neustart"
              aria-label="Neustart"
            >
              {face}
            </button>
            <div className="flex items-center gap-3">
              <div className="text-xs uppercase tracking-wider opacity-70">Flaggen</div>
              <div className="text-lg font-mono tabular-nums">{remainingFlags}</div>
              <div className="ml-4 text-xs uppercase tracking-wider opacity-70">Zeit</div>
              <div className="text-lg font-mono tabular-nums w-14 text-right">{timeStr}</div>
            </div>
          </div>

          <div className="overflow-auto rounded-xl border border-slate-700">
            <div
              className="grid"
              style={{ gridTemplateColumns: `repeat(${cols}, minmax(0, 1fr))` }}
            >
              {board.map((row, r) =>
                row.map((cell, c) => (
                  <button
                    key={`${r}-${c}`}
                    onClick={() => (cell.revealed ? chordReveal(r, c) : reveal(r, c))}
                    onContextMenu={(e) => toggleFlag(e, r, c)}
                    className={[
                      "relative aspect-square flex items-center justify-center select-none font-semibold",
                      "border border-slate-700",
                      cell.revealed
                        ? "bg-slate-800 text-slate-100"
                        : "bg-slate-700/70 hover:bg-slate-600/70 active:translate-y-px",
                      cell.exploded ? "bg-rose-700 text-white animate-pulse" : "",
                      focusPos.r === r && focusPos.c === c ? "ring-2 ring-sky-400 ring-offset-2 ring-offset-slate-900" : "",
                    ].join(" ")}
                    aria-label={cell.revealed ? (cell.isMine ? "Mine" : `${cell.adjacent} angrenzend`) : "verdeckt"}
                  >
                    {!cell.revealed && cell.flagged && <span title="Flagge">üö©</span>}
                    {cell.revealed && !cell.isMine && cell.adjacent > 0 && (
                      <span className="drop-shadow-sm" style={{
                        // Farbskala f√ºr Zahlen 1..8 an klassische Minesweeper-Farben angelehnt
                        color:
                          cell.adjacent === 1 ? "#3b82f6" :
                          cell.adjacent === 2 ? "#16a34a" :
                          cell.adjacent === 3 ? "#dc2626" :
                          cell.adjacent === 4 ? "#1d4ed8" :
                          cell.adjacent === 5 ? "#b91c1c" :
                          cell.adjacent === 6 ? "#0891b2" :
                          cell.adjacent === 7 ? "#111827" :
                          "#6b7280"
                      }}>{cell.adjacent}</span>
                    )}
                    {cell.revealed && cell.isMine && <span title="Mine">üí£</span>}
                    {!cell.revealed && !cell.flagged && <span className="sr-only">verdeckt</span>}
                  </button>
                ))
              )}
            </div>
          </div>

          <div className="mt-4 flex items-center justify-between gap-3 text-sm">
            <div className="opacity-80">
              Status: {state === "ready" ? "bereit" : state === "playing" ? "l√§uft" : state === "won" ? "gewonnen" : "verloren"}
            </div>
            <div className="flex items-center gap-2">
              <button onClick={() => reset(rows, cols, mines)} className="px-3 py-1.5 rounded-xl border border-slate-600 hover:border-slate-400">Neustart</button>
              <button onClick={() => reset(PRESETS.Beginner.rows, PRESETS.Beginner.cols, PRESETS.Beginner.mines)} className="px-3 py-1.5 rounded-xl border border-slate-600 hover:border-slate-400">Zur√ºcksetzen (Beginner)</button>
            </div>
          </div>
        </div>

        <footer className="mt-4 text-xs opacity-70">
          Tipp: Mit den Pfeiltasten navigieren, <kbd className="px-1 rounded bg-slate-700">Enter</kbd>/<kbd className="px-1 rounded bg-slate-700">Leertaste</kbd> zum Aufdecken, <kbd className="px-1 rounded bg-slate-700">F</kbd> zum Flaggen. Rechtsklick setzt ebenfalls Flaggen.
        </footer>
      </div>
    </div>
  );
}
